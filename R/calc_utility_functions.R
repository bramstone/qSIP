# Collection of functions to make calculation function code neater

# Calculation of 16S copies per taxon from relative abundances and 16S copy numbers
# Note, will return a feature table with taxa as columns
copy_no <- function(data, rel_abund=TRUE) {
  ft <- as(data@otu_table, 'matrix')
  # make taxa columns and samples rows
  if(phyloseq::taxa_are_rows(data)) ft <- t(ft)
  # relative abundances
  if(rel_abund) ft <- ft / base::rowSums(ft, na.rm=TRUE)
  # multiply by total 16S copy number per sample
  ft <- ft * data@sam_data[[data@qsip@abund]]
  ft[is.nan(ft)] <- 0
  return(ft)
}

# Function to generate small reference data frame of unique isotope and isotope x grouping combinations
# to use with grouped calculations where the light and heavy treatments must be identified
iso_grouping <- function(data, iso, rep_id, grouping) {
  if(length(data@qsip@rep_group)==0) grouping <- 1 else grouping <- data@sam_data[[grouping]]
  output <- data.frame(iso=data@sam_data[[iso]],
                       replicate=data@sam_data[[rep_id]],
                       grouping=grouping)
  #if(length(data@qsip@rep_group)==0) {
 #   output$interaction <- output$iso
 #   output$full.interaction <- output$interaction
 # } else {
    output$interaction <- interaction(output$iso, output$grouping)
    output$full.interaction <- interaction(output$replicate, output$interaction)
#  }
  output <- output[!duplicated(output$full.interaction) | is.na(output$full.interaction),]
  output$full.interaction <- NULL
  rownames(output) <- NULL
  return(output)
}

# Function to generate small reference data frame of unique replicate and timepoint combinations
# to use with pop calculations where the time 0 and time t must be identified
time_grouping <- function(data, timepoint, rep_id, grouping) {
  if(length(data@qsip@rep_group)==0) grouping <- 1 else grouping <- data@sam_data[[grouping]]
  output <- data.frame(time=data@sam_data[[timepoint]],
                       replicate=data@sam_data[[rep_id]],
                       grouping=grouping)
  #if(length(data@qsip@rep_group)==0) {
  #  output$interaction <- output$time
  #  output$full.interaction <- output$interaction
  #} else {
    output$interaction <- interaction(output$time, output$grouping)
    output$full.interaction <- interaction(output$replicate, output$interaction)
  #}
  output <- output[!duplicated(output$full.interaction) | is.na(output$full.interaction),]
  output$full.interaction <- NULL
  rownames(output) <- NULL
  return(output)
}

# Function used to split qSIP data into list of sub-matrices
split_data <- function(data, new_data, grouping, grouping_w_phylosip=T, keep_names=0) {
  if(grouping_w_phylosip) grouping <- data@sam_data[[grouping]]
  if(keep_names==1) {
    sam_names <- rownames(new_data)
    sam_names <- split(sam_names, grouping)
  } else if(keep_names==2) {
    sam_names <- rownames(new_data)
    sam_names <- split(sam_names, grouping)
  }
  n_taxa <- ncol(new_data)
  new_data <- split(new_data, grouping)
  new_data <- base::lapply(new_data, matrix,
                     byrow=FALSE,
                     ncol=n_taxa)

  if(keep_names==1) {
    new_data <- base::Map(function(x,y) {rownames(x) <- y; x}, new_data, sam_names)
  } else if(keep_names==2) {
    new_data <- base::Map(function(x,y) {colnames(x) <- y; x}, new_data, sam_names)
  }
  return(new_data)
}

# Function used to handle adding new data to phylosip object .Data slot (data@qsip@.Data)
# parameter ... Indicates options to pass to Matrix, for specifying whether it should be sparse or not
collate_results <- function(data, new_data, tax_names=NULL, metric, ...) {
  if(is.null(tax_names)) {
    # compare columns of new matrix to full tax list
    if(ncol(new_data)==phyloseq::ntaxa(data)) {
      tax_names <- phyloseq::taxa_names(data)
    } else if(length(data@qsip@filter) > 0) {
      tax_names <- data@qsip@filter
    }
  }
  # combine format based on whether taxa were rows or not
  if(class(new_data)=='list') {
    if(phyloseq::taxa_are_rows(data)) {
      new_data <- do.call(cbind, new_data)
      if(is.null(rownames(new_data))) {
        rownames(new_data) <- tax_names
      }
    } else {
      new_data <- do.call(rbind, new_data)
      if(is.null(colnames(new_data))) {
        colnames(new_data) <- tax_names
      }
    }
    new_data <- Matrix::Matrix(new_data, ...)
    # add feature names back in (replicate names automatically utilized from split)
  } else if(class(new_data)=='matrix') {
    if(phyloseq::taxa_are_rows(data)) new_data <- t(new_data)
    if(is.null(rownames(new_data))) {
      rownames(new_data) <- tax_names
    } else if(is.null(colnames(new_data))) {
      colnames(new_data) <- tax_names
    }
    # convert to S4 Matrix which is more memory efficient
    new_data <- Matrix::Matrix(new_data, ...)
  } else if(class(new_data)=='numeric' && is.null(names(new_data))) names(new_data) <- tax_names
  # add wad values to data slot of qSIP portion of object
  if(any(attributes(data@qsip)$names %in% metric)) { # if wad alreay exists, replace
    warning('Overwriting existing ', metric, ' values', call.=FALSE)
    replace_num <- which(attributes(data@qsip)$names %in% metric)
    data@qsip@.Data[[replace_num]] <- new_data
  } else { # else append it to the list and update the list names
    data@qsip@.Data[[length(data@qsip@.Data) + 1]] <- new_data
    attributes(data@qsip)$names[length(data@qsip@.Data)] <- metric
  }
  return(data)
}

# function that generates confidence intervals for a metric (lower CI, median, upper CI)
# also handles column names. Returns a list
summarize_ci <- function(bootstraps, ci, grouping, ncols, list_names=c('ci_l', 'med', 'ci_u'), data) {
  summaries <- t(apply(bootstraps, 1,
                       quantile,
                       c((1 - ci)/2, .5, (1 - ci)/2 + ci),
                       na.rm=TRUE))
  ci_l <- summaries[,1]
  med <- summaries[,2]
  ci_u <- summaries[,3]
  # arrange into matrices
  ci_l <- matrix(ci_l, ncol=ncols, byrow=T)
  med <- matrix(med, ncol=ncols, byrow=T)
  ci_u <- matrix(ci_u, ncol=ncols, byrow=T)
  # assign rownames (colnames assigned in collate_results)
  if(length(data@qsip@rep_group)==0) {
    rownames(ci_l) <- rownames(med) <- rownames(ci_u) <- levels(grouping[,1])[2:nlevels(grouping[,1])]
  } else {
    rnames <- expand.grid(levels(grouping$grouping),
                          levels(grouping[,1])[2:nlevels(grouping[,1])],
                          stringsAsFactors=FALSE)
    rownames(ci_l) <- rownames(med) <- rownames(ci_u) <- interaction(rnames[,1], rnames[,2], sep=':')
  }
  # put into list and return
  output <- list(ci_l, med, ci_u)
  names(output) <- list_names
  return(output)
}

# function that removes invalid (missing) rows between matrix (ft, WADS, diff_WADS, etc.) and grouping data.frame
# returns a list of 2; [[1]] is the matrix, [[2]] is the grouping data.frame with invalid rows removed
# samples should be rows in feature table
valid_samples <- function(data, feature_table, grouping=c('iso', 'time'), quiet=FALSE, match_replicate=FALSE) {
  grouping <- match.arg(grouping, c('iso', 'time'))
  # grouping by isotope or timepoint?
  if(grouping=='iso') {
    group_data <- iso_grouping(data, data@qsip@iso_trt, data@qsip@rep_id, data@qsip@rep_group)
  } else {
    group_data <- time_grouping(data, data@qsip@timepoint, data@qsip@rep_id, data@qsip@rep_group)
  }
  # if matching replicates, identify any samples that are unmatched between time 0 and time t
  if(match_replicate) {
    rep_nums <- unique(as(data@sam_data[,c(data@qsip@rep_id, data@qsip@rep_num)], 'data.frame'))
    names(rep_nums) <- c('replicate', 'replicate_num')
    matching <- merge(group_data, rep_nums, all.x=TRUE)
    # remove light samples from abundance calcs, before determining un-matched replicates
    light_group <- iso_grouping(data, data@qsip@iso_trt, data@qsip@rep_id, data@qsip@rep_group)
    light_group <- light_group[as.numeric(light_group$iso)==1,]
    matching <- matching[!matching$replicate %in% light_group$replicate,]
    # split, sum up number of rows for each replicate, discard if only 1
    matching <- split(matching, interaction(matching$grouping, matching$replicate_num))
    matching <- lapply(matching, function(x) {if(nrow(x)==1) x$replicate_num <- NA; x})
    matching <- do.call(rbind, matching)
    matching <- merge(matching, rep_nums[!rep_nums$replicate %in% matching$replicate,], all=TRUE)
    group_data <- merge(group_data, matching[,c('replicate', 'replicate_num')], all.x=TRUE)
    group_data <- group_data[order(group_data$interaction, group_data$replicate_num),]
  }
  # identify any NAs that occur across iso/timepoint column, replicate IDs, or grouping variable
  invalid <- sapply(group_data, is.na)
  invalid <- apply(invalid, 1, any)
  # issue warning of samples lost
  if(sum(invalid) > 0 && quiet==FALSE) {
    warning('Dropping sample(s): ',
            paste(as.character(group_data$replicate[invalid]), collapse=', '),
            ' - from calculation', call.=FALSE)
  }
  # match matrix rows with samples with complete data
  group_data <- group_data[!invalid,]
  # re-level factors
  group_data <- data.frame(lapply(group_data, factor))
  feature_table <- feature_table[match(group_data$replicate, rownames(feature_table)),]
  # return data
  return(list(feature_table, group_data))
}


# function which recombines randomly subsampled matrix in the correct order so that downstream calculations will
# be performed on the correct subsets
recombine_in_order <- function(ft, grouping, n_taxa, condensed_grouping=FALSE) {
  if(condensed_grouping) {
    # pop value abundances are summarized, reducing number of samples of each group to 1
    grouping <- grouping[!duplicated(grouping$interaction),]
    group_counts <- nlevels(grouping$interaction)
  } else group_counts <- sapply(ft, nrow)
  which_group <- as.numeric(grouping$interaction)
  temp <- matrix(nrow=sum(group_counts), ncol=n_taxa)
  for(i in 1:nlevels(grouping$interaction)) {
    temp[which_group==i,] <- ft[[i]]
  }
  return(temp)
}

# function which tests label and light values for matching replicates
match_reps <- function(data, wad_label, wad_light, grouping, rep_group=FALSE, global_light=FALSE) {
  reps <- unique(as(data@sam_data[,c(data@qsip@rep_id, data@qsip@rep_num)], 'data.frame'))
  names(reps) <- c('replicate', 'replicate_num')
  reps <- merge(grouping, reps, all.x=TRUE)
  if(rep_group==TRUE) {
    reps$replicate_num <- interaction(reps$grouping, reps$replicate_num)
  }
  reps$replicate <- as.character(reps$replicate)
  reps2 <- reps
  reps <- split(reps, reps$replicate_num)
  issues <- vector('logical', length(reps))
  #
  for(n in 1:length(reps)) {
    n_light <- reps[[n]][as.numeric(reps[[n]]$iso)==1,]
    n_label <- reps[[n]][as.numeric(reps[[n]]$iso)==2,]
    #
    # check unlabeled
    if(nrow(n_light)==0) {
      if(rep_group==FALSE) {
        # use global averages
        wl_av <- colMeans(wad_light, na.rm=TRUE)
        wl_av[is.nan(wl_av)] <- NA
      } else {
        # use group averages
        group_n <- reps[[n]]$grouping
        wl_av <- colMeans(wad_light[reps2$grouping==group_n,], na.rm=TRUE)
        wl_av[is.nan(wl_av)] <- NA
      }
      warning('Missing unlabeled replicate to compare against ',
              reps[[n]]$replicate[as.numeric(reps[[n]]$iso)==2],
              '\nUsing average of unlabeled replicates', call.=FALSE)
      reps[[n]] <- rbind(reps[[n]],
                         c(replicate=paste(levels(grouping$iso)[1], 'avg', sep='.'),
                           iso=levels(grouping$iso)[1],
                           grouping=1,
                           interaction=paste0(levels(grouping$iso)[1], '.1')))
      wad_light <- rbind(wad_light, wl_av)
      rownames(wad_light)[grepl('wl_av', rownames(wad_light))] <- paste(levels(grouping$iso)[1], 'avg', sep='.')
      #
    } else if(nrow(n_light) > 1) {
      # if duplicated light values, average and combine
      light_duplicated <- reps[[n]]$replicate[as.numeric(reps[[n]]$iso)==1]
      warning('Duplicate unlabeled replicates: ', paste(light_duplicated, collapse=', '),
              '\nMatched to replicate: ', names(reps)[n],
              '. Using average of duplicates', call.=FALSE)
      wl_av <- wad_light[light_duplicated,]
      wl_av <- colMeans(wl_av, na.rm=T)
      wl_av[is.nan(wl_av)] <- NA
      reps[[n]] <- rbind(reps[[n]],
                         c(replicate=paste(levels(grouping$iso)[1], names(reps)[n], sep='.'),
                           iso=levels(grouping$iso)[1],
                           grouping=1,
                           interaction=paste0(levels(grouping$iso)[1], '.1'),
                           replicate_num=n))
      reps[[n]] <- reps[[n]][!reps[[n]]$replicate %in% light_duplicated,]
      wad_light <- rbind(wad_light, wl_av)
      rownames(wad_light)[grepl('wl_av', rownames(wad_light))] <- paste(levels(grouping$iso)[1], names(reps)[n], sep='.')
      issues[n] <- TRUE
      #
    }
    #
    # check labeled
    if(nrow(n_label)==0) {
      # remove the unmatched unlabeled value
      warning('Missing labeled replicate',
              '\nRemoving replicates:',
              paste(reps[[n]]$replicate[as.numeric(reps[[n]]$iso)==1], collapse=', '),
              ' - from calculation', call.=FALSE)
      reps[[n]] <- reps[[n]][0,]
      #
    } else if(nrow(n_label) > 1) {
      # if duplicated label values, average and combine
      label_duplicated <- reps[[n]]$replicate[as.numeric(reps[[n]]$iso)==2]
      warning('Duplicate labeled replicates: ', paste(label_duplicated, collapse=', '),
              '\nMatched to replicate: ', names(reps)[n],
              '. Using average of duplicates', call.=FALSE)
      wh_av <- wad_label[label_duplicated,]
      wh_av <- colMeans(wh_av, na.rm=T)
      wh_av[is.nan(wh_av)] <- NA
      reps[[n]] <- rbind(reps[[n]],
                         c(replicate=paste(levels(grouping$iso)[2], names(reps)[n], sep='.'),
                           iso=levels(grouping$iso)[2],
                           grouping=1,
                           interaction=paste0(levels(grouping$iso)[2], '.1'),
                           replicate_num=n))
      reps[[n]] <- reps[[n]][!reps[[n]]$replicate %in% label_duplicated,]
      wad_label <- rbind(wad_label, wh_av)
      rownames(wad_label)[grepl('wh_av', rownames(wad_label))] <- paste(levels(grouping$iso)[2], names(reps)[n], sep='.')
      issues[n] <- TRUE
      #
    }
  }
  if(any(issues)) warning('Check that data@qsip@rep_num contains unique names for every treatment and/or group', call.=FALSE)
  reps <- do.call(rbind, reps)
  reps_h <- droplevels(reps[as.numeric(reps$iso)==2,])
  reps_l <- droplevels(reps[as.numeric(reps$iso)==1,])
  if(rep_groups) {
    wad_label <- do.call(rbind, wad_label)
    wad_light <- do.call(rbind, wad_light)
    if(global_light) {
      #
      global_wl <- colMeans(global_wl, na.rm=TRUE)
      global_wl[is.nan(global_wl)] <- NA
      #
      wad_light[1:nrow(wad_light),] <- global_wl
    }
  }
  return(list(wad_label[match(reps_h$replicate, rownames(wad_label)),],
              wad_light[match(reps_l$replicate, rownames(wad_light)),]))
}


# function which tests label and light values for matching groups
match_groups <- function(data, wad_label, wad_light, grouping, global_light=FALSE) {
  groups <- unique(grouping[,c('iso', 'grouping', 'interaction')])
  groups2 <- groups
  groups <- split(groups, groups$grouping)
  #
  global_wl <- do.call(rbind, wad_light)
  global_wl <- colMeans(global_wl, na.rm=TRUE)
  global_wl[is.nan(global_wl)] <- NA
  #
  for(n in 1:length(groups)) {
    n_light <- groups[[n]][as.numeric(groups[[n]]$iso)==1,]
    n_label <- groups[[n]][as.numeric(groups[[n]]$iso)==2,]
    #
    # if missing light group
    if(nrow(n_light)==0) {
      groups[[n]] <- rbind(groups[[n]],
                           c(iso=levels(groups2$iso)[1],
                             grouping=names(groups)[n],
                             interaction=interaction(levels(groups2$iso)[1], names(groups)[n])))
      wad_light <- c(wad_light, list(global_wad_light=global_wl))
      names(wad_light)[grepl('global_wad_light', names(wad_light))] <- interaction(levels(groups2$iso)[1], names(groups)[n])
      warning('Missing unlabeled group to compare against ',
              groups[[n]]$replicate[as.numeric(groups[[n]]$iso)==2],
              '\nUsing average of unlabeled groups', call.=FALSE)
    }
    #
    # if missing label group
    if(nrow(n_label)==0) {
      # remove the unmatched unlabeled value
      warning('Missing labeled group',
              '\nRemoving group:',
              paste(groups[[n]]$grouping[as.numeric(groups[[n]]$iso)==1], collapse=', '),
              ' - from calculation', call.=FALSE)
      # groups[[n]] <- groups[[n]][0,]
      wad_light[[n]] <- NULL
    }
  }
  #
  if(global_light) wad_light <- base::lapply(wad_light, function(x) global_wl)
  # groups <- do.call(rbind, groups)
  # groups$interaction <- as.character(groups$interaction)
  # groups_h <- droplevels(groups[as.numeric(groups$iso)==2,])
  # groups_l <- droplevels(groups[as.numeric(groups$iso)==1,])
  return(list(wad_label, wad_light))
  # return(list(wad_label[match(groups_h$interaction, names(wad_label))],
  #             wad_light[match(groups_l$interaction, names(wad_light))]))
}
